# -*- coding: utf-8 -*-
"""Resume_generation_Gemini_pro.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16z793IRwVmvKYCaOLGZFDYj-XOj8zEJL
"""

# from google.colab import drive,userdata

# drive.mount('/content/drive')

# !pip install streamlit -qq

# !pip install PyPDF2 -qq

# !pip install langchain_community -qq

# !pip install langchain_google_genai -qq

# !pip install python-docx -qq

# !pip install docx2txt -qq

# !pip install faiss-gpu -qq

# !pip install google-generativeai -qq

# !pip install --upgrade google-generativeai -qq

import docx2txt
import PyPDF2
import subprocess
def extract_text(file_path):
    if file_path.endswith(".docx"):
        # Extract text from DOCX file
        return docx2txt.process(file_path)

    elif file_path.endswith(".pdf"):
        # Extract text from PDF file
        text = ""
        with open(file_path, 'rb') as file:
            reader = PyPDF2.PdfReader(file)
            for page_num in range(len(reader.pages)):
                text += reader.pages[page_num].extract_text()
        return text

    else:
        raise ValueError("Unsupported file type")

# from google.colab import auth
# auth.authenticate_user()

import os
# GOOGLE_APPLICATION_CREDENTIALS = os.environ["GOOGLE_APPLICATION_CREDENTIALS"]
# private_key_id = os.environ.get('PRIVATE_KEY_ID')
# private_key = os.environ.get('PRIVATE_KEY')
# client_id = os.environ.get('CLIENT_ID')

# !pip install python-docx

import os
import streamlit as st
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.vectorstores.faiss import FAISS
# from google.colab import drive
from docx import Document
import google.generativeai as genai
from datetime import datetime

api_key_google = os.environ.get('GOOGLE_GEMINI_KEY')
genai.configure(api_key=api_key_google)

# Mount Google Drive
# drive.mount('/content/drive')

model = genai.GenerativeModel('gemini-pro')

def save_resume_to_docx(tailored_resume, file_path):
    doc = Document()
    doc.add_heading('Tailored Resume', level=1)
    doc.add_paragraph(tailored_resume)
    doc.save(file_path)

def save_resume_to_pdf(docx_file_path, file_path):
    subprocess.run(['libreoffice', '--headless', '--convert-to', 'pdf', '--outdir', file_path, docx_file_path])


# Function to read text from a .docx file
def read_docx(file_path):
    doc = Document(file_path)
    return "\n".join([para.text for para in doc.paragraphs])

def generate_resume_text(resume_text):
    prompt = f"""
Given the following resume content:

[Resume Start]
{resume_text}
[Resume End]

Format this resume content with appropriate section titles. Only use the information provided and avoid placeholders like "[Your Name]". Ensure it retains the structure and details exactly as shown.
"""
    try:
        response = model.generate_content(prompt)
        print(response)
        # Accessing the generated text content
        return response.candidates[0].content.parts[0].text
    except Exception as e:
        print("Error in generating resume text:", e)
        return None

def tailor_resume(resume_text, job_description):
    # Use the generate_resume_text function to get the formatted resume content
    formatted_resume = generate_resume_text(resume_text)
    print("formatted resume:",formatted_resume)
    if formatted_resume:
        prompt = f"""
Below is the candidate's original formatted resume content:

[Resume Start]
{formatted_resume}
[Resume End]

Using the candidate's resume above and the job description below, create a tailored resume.

[Job Description Start]
{job_description}
[Job Description End]

Please generate a resume that:
1. Uses real data from the candidate's resume, including name, and education.
2. Avoids placeholders like "[Your Name]" and includes actual details.
3. In the experience section, emphasizes professional experiences and skills that are directly relevant to the job description.
4. Keeps only a maximum of the top three accomplishments/ responsibilities for each job position held so as to make the candidate standout in the new job role
5. Removes special characters from the section titles
6. Only includes publications if the job description is research based
7. Summarizes the skills and technical skills section into a brief profile
8. Does not include courses, certification, references, skills and a technical skills sections
"""
        try:
            response = model.generate_content(prompt)
            return response.candidates[0].content.parts[0].text
        except Exception as e:
            print("Error in tailoring resume:", e)
            return None
    else:
        return "Failed to generate resume text."

#Entry function for the model
def generate_gemini(current_resume,job_description , download_path , doctype):
    st.header('Resume Tailoring')
    # Load the resume and job description from Google Drive
    resume_text = extract_text(current_resume)
    job_description = extract_text(job_description)

    # Tailor resume based on job description
    tailored_resume = tailor_resume(resume_text, job_description)
    st.write("**Tailored Resume:**")
    st.write(tailored_resume)
    print(tailored_resume)

        # Save the tailored resume to a .docx file
    if tailored_resume:
        time = datetime.now().strftime('%Y%m%d_%H%M%S')
        file_name = f"Tailored_Resume_{time}.docx"
        file_path = os.path.join(download_path , file_name)
        save_resume_to_docx(tailored_resume, file_path)
        if(doctype == 'pdf'):
            file_name = f"Tailored_Resume_{time}.pdf"
            save_resume_to_pdf(file_path, download_path)
            file_path = os.path.join(download_path , file_name)

        st.success(f"Download tailored resume")
        # st.success(f"Tailored resume saved to {file_path}")        

    return tailored_resume, file_path

# Main function for Streamlit app
# def Gemini_pro_main(current_resume,job_description):
#     st.header('Resume Tailoring')

#     # Load the resume and job description from Google Drive
#     resume_text = extract_text(current_resume)
#     job_description = extract_text(job_description)

#     # Tailor resume based on job description
#     tailored_resume = tailor_resume(resume_text, job_description)
#     st.write("**Tailored Resume:**")
#     st.write(tailored_resume)
#     print(tailored_resume)

#         # Save the tailored resume to a .docx file
#     if tailored_resume:
#         file_path = f"Tailored_Resume_{datetime.now().strftime('%Y%m%d_%H%M%S')}.docx"
#         save_resume_to_docx(tailored_resume, file_path)
#         st.success(f"Tailored resume saved to {file_path}")

# if __name__ == '__main__':
#     main()

